<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebView 技术]]></title>
    <url>%2F2017%2F04%2F10%2F2017-4-10-webview%2F</url>
    <content type="text"><![CDATA[WebView开发教程…持续整理中… WebView 简介WebView 提供了四个配置类来定制 WebView 的各种行为及表现，分别是： WebSettings WebViewClient WebChromeClient JavaScriptInterface WebSettings Manages settings state for a WebView. When a WebView is first created, it obtains a set of default settings. These default settings will be returned from any getter call. A WebSettings object obtained from WebView.getSettings() is tied to the life of the WebView. If a WebView has been destroyed, any method call on WebSettings will throw an IllegalStateException WebViewClientWebChromeClient5JavaScriptInterface Annotation that allows exposing methods to JavaScript. Starting from API level JELLY_BEAN_MR1 and above, only methods explicitly marked with this annotation are available to the Javascript code. See addJavascriptInterface(Object, String) for more information about it. 该注解允许将指定的方法公开给 JavaScript 调用，要求 Api&gt;=17，否则在 js 代码中是无法调用 android 端的方法的。 这个是结合 addJavascriptInterface 来使用：123456789/** * JS调用 * 如果 targetSdkVersion &gt;=17，一定要加注解，否则JS无法调用这个方法 */@JavascriptInterfacepublic void jsCallNative(String jsParasJson) &#123; IMLogger.d("jsCallNative jsParasJson=" + jsParasJson); sendMessageToManager(WebViewManager.MSG_JS_CALL, jsParasJson);&#125; 在 js 中的调用逻辑是：123456/** js调用android方法*/function jsCallJavaByInterface(arg) &#123; AndroidObj.jsCallNative(arg);&#125; 上面的 AndroidObj 实际上是一个 Android interface对象，这面这个 js 方法被调用的时候，要确保本地这个对象已经创建，否则会调用失败。 在初始化 WebView 的时候，可以使用addJavascriptInterface显示的创建一个AndroidObj对象，这个对像可供 js 端调用。 该函数的1234// 声明// void addJavascriptInterface (Object object, String name)// 使用mWebView.addJavascriptInterface(WebViewWithFavActivity.this, "AndroidObj"); addJavascriptInterface的第一个参数是一个Object，它与第二个参数存在类成员的关系，比如上面的jsCallNative方法，是写在WebViewWithFavActivity中的。 引用 WebView 概述 Building Web Apps in WebView]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS 自动化测试]]></title>
    <url>%2F2017%2F03%2F28%2F2017-3-28-as-test%2F</url>
    <content type="text"><![CDATA[本文主要讲解 ATSL 测试框架 JUnit 3 vs Junit 4 AndroidJUnitRunner是一个可以用来运行JUnit 3和JUnit 4样式的测试类的Test Runner，并且同时支持Espresso和UI Automator。这是对于之前的InstrumentationTestRunner的一个升级，如果你去查看Gradle文档中对于Testing配置的说明，会发现推荐的Test Runner为InstrumentationTestRunner。InstrumentationTestRunner只支持JUnit 3样式的测试用例，而我们在写Android测试用例时应该尽可能使用JUnit 4样式来实现。 相对于Junit 3， JUnit 4有如下改进： 在JUnit3中需要继承TestCase类，但在JUnit4中已经不需要继承TestCase 可以使用类似@Test, @Before, @After等注解来管理自己的测试方法。在JUnit3中需要覆盖TestCase中的setUp和tearDown方法，其中setUp方法会在测试执行前被调用以完成初始化工作，而tearDown方法则在结束测试结果时被调用，用于释放测试使用中的资源，而在JUnit4中，只需要在方法前加上@Before，@After 测试方法名不再需要以test开头。在JUnit3中对某个方法进行测试时，测试方法的命令是固定的，例如对addBook这个方法进行测试，需要编写名字为tetAddBook的测试方法，而在JUnit4中没有方法命令的约束，在方法的前面加上@Test,这就代表这个方法是测试用例中的测试方法 新的断言assertThat @BeforeClass 和 @AfterClass 。在JUnit3，如果所有的test case仅调用一次setUp()和tearDown()需要使用TestSetup类 测试异常处理@Test(expected = DataFormatException.class) 设置超时@Test(timeout = 1000) 忽略测试@Ignore 支持对assert方法的static导入。 增加了一些Assert方法； 使用 Junit 4 风格的 Espresso APIs 来编写的测试用例如下：1234567891011121314@RunWith(AndroidJUnit4.class)@LargeTestpublic class MainActivityInstrumentationTest &#123; @Rule public ActivityTestRule mActivityRule = new ActivityTestRule&lt;&gt;( MainActivity.class); @Test public void sayHello()&#123; onView(withText("Say hello!")).perform(click()); onView(withId(R.id.textView)).check(matches(withText("Hello, World!"))); &#125;&#125; Junit 4支持以下注解来管理测试用例 @Before: 标识在运行测试方法之前运行的代码。可以支持同一个Class中有多个@Before，但是这些方法的执行顺序是随机的。该注解替代了JUnit 3中的setUp()方法。 @After: 标识在运行测试方法结束之后运行的代码。可以在其中做一些释放资源的操作。该注解替代了JUnit 3中的tearDown()方法。 @Test: 标识一个测试方法。一个测试类中可以有多个测试方法，每个测试方法需要用一个@Test注解来标识。 @Rule: 简单来说，是为各个测试方法提供一些支持。具体来说，比如我需要测试一个Activity，那么我可以在@Rule注解下面采用一个ActivityTestRule，该类提供了对相应Activity的功能测试的支持。该类可以在@Before和@Test标识的方法执行之前确保将Activity运行起来，并且在所有@Test和@After方法执行结束之后将Activity杀死。在整个测试期间，每个测试方法都可以直接对相应Activity进行修改和访问。 @BeforeClass: 为测试类标识一个static方法，在测试之前只执行一次。 @AfterClass: 为测试类标识一个static方法，在所有测试方法结束之后只执行一次。 @Test(timeout=): 为测试方法设定超时时间。 区别 Espresso 侧重于应用内测试 + 不支持 WebView UiAutomator 支持 WebView，应用内测试也ok，但是 api 的优雅性不如 Espresso Espresso 自动化测试 Google 新退出的自动化测试框架，除了不支持 WebView，其它的测试功能都能很好的支持。 获取 ContextEspresso 中获取 Context 是通过1234@Rulepublic ActivityTestRule&lt;MainActivity&gt; mActivityRule = new ActivityTestRule&lt;&gt;( MainActivity.class);Context context = mActivityRule.getActivity().getApplicationContext(); 测试用例是工程强相关的，上面的 MainActivity 测试工程的主 UI，ActivityTestRule 这个类提供了相应的 Activity 测试支持。 常规 View 测试例子如下：123456@Test public void changeText_sameActivity() &#123; onView(withId(R.id.editTextUserInput)).perform(typeText(STRING_TO_BE_TYPED), closeSoftKeyboard()); onView(withId(R.id.changeTextBt)).perform(click()); onView(withId(R.id.textToBeChanged)).check(matches(withText(STRING_TO_BE_TYPED))); &#125; ViewMachers withId: 使用控件 ID 匹配一个 [Matcher]，具体的api见文档withText: 使用 String 返回一个 Matcher 12public static Matcher&lt;View&gt; withId(final int id);public static Matcher&lt;View&gt; withText(String text); onView: 使用一个 Matcher 查找一个 ViewInteraction 12public static ViewInteraction onView(final Matcher&lt;View&gt; viewMatcher);public ViewInteraction check(final ViewAssertion viewAssert); // 配合 matches 来做校验操作 ViewActions 操作 123456789public static ViewAction click() // 点击事件public static ViewAction typeText(String stringToBeTyped) // 输入事件public static ViewAction closeSoftKeyboard() // 关闭键盘public ViewInteraction perform(final ViewAction... viewActions) // 执行一系列的 viewActions 操作// typeText 输入text// closeSoftKeyboard() 关闭软键盘onView(withId(R.id.editText)) .perform(typeText(mValidStringToBeTyped), closeSoftKeyboard()) .check(matches(withText(mValidStringToBeTyped))); 测试工程 vs 主工程在写测试用例的过程，除了能通过 onView 获取到主工程中的 View 控件，这是一个 ViewInteraction 类型，它暴露的 api 接口有限，无法通过它来获取控件的内容，这个时候就需要其它方法了；比如我们需要获取 主工程中 TextView 或者 EditText 的内容等。12345678910111213141516171819202122// 此处入参是 String 类型，返回的是一个 Matcherstatic Matcher&lt;View&gt; withHint(final String substring) &#123; return withHint(is(substring)); &#125;static Matcher&lt;View&gt; withHint(final Matcher&lt;String&gt; stringMatcher) &#123; checkNotNull(stringMatcher); return new BoundedMatcher&lt;View, EditText&gt;(EditText.class) &#123; @Override public boolean matchesSafely(EditText view) &#123; final CharSequence hint = view.getHint(); return hint != null &amp;&amp; stringMatcher.matches(hint.toString()); &#125; @Override public void describeTo(Description description) &#123; description.appendText("with hint: "); stringMatcher.describeTo(description); &#125; &#125;; &#125; 通过 Matcher，结合 check、matches 来一起达到验证的目的。使用方法如下：1onView(withId(R.id.editText)).check(matches(HintMatcher.withHint(hintText))); ListView Adapter 测试 View 滑动这里只需要弄清楚一个 List 的滑动接口就好。 123456789101112private static DataInteraction onRow(String str)&#123; // 滑动到value=str指定的item中 // LongListActivity.ROW_TEXT 这个属性是在创建 Adapter 时对应子 View 的一个 id，后面的值是对应的 id 赋值 DataInteraction dataInteraction = onData(hasEntry(equalTo(LongListActivity.ROW_TEXT), is(str))); try &#123; sleep(3000); // 这里添加参数只是为了方便演示 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return dataInteraction;// return onData(hasEntry(equalTo(LongListActivity.ROW_TEXT), is(str))); &#125; 子 View 的点击 1234// 滑到 TEXT_ITEM_30 这一行 点击相应的 id 操作onRow(TEXT_ITEM_30).onChildView(withId(R.id.rowToggleButton)).perform(click());// 滑到 TEXT_ITEM_30 这一行 找到相应的 View，判断 ToggleButton 点击态onRow(TEXT_ITEM_30).onChildView(withId(R.id.rowToggleButton)).check(matches(isChecked())); 异步测试实际测试过程中，对于比较耗时的操作进行操作，需要考虑异步问题，这里可以采用测试工程通过主动 sleep 来解决，但是这个操作本身不够友好，此时可以通过 IdlingResource 来处理。这个接口类说明如下：1234567891011121314151617 public interface IdlingResource &#123; //用于日志显示的名字，可随意取 public String getName(); //是否是空闲状态 public boolean isIdleNow(); //注册变成空闲的回调 public void registerIdleTransitionCallback(ResourceCallback callback); //回调接口 public interface ResourceCallback &#123; public void onTransitionToIdle(); &#125;&#125; 这里可以给一个简单的实现123456789101112131415161718192021222324252627282930313233public class SimpleIdlingResource implements IdlingResource &#123; @Nullable private volatile ResourceCallback mCallback; // Idleness is controlled with this boolean. private AtomicBoolean mIsIdleNow = new AtomicBoolean(true); @Override public String getName() &#123; return this.getClass().getName(); &#125; @Override public boolean isIdleNow() &#123; return mIsIdleNow.get(); &#125; @Override public void registerIdleTransitionCallback(ResourceCallback callback) &#123; mCallback = callback; &#125; /** * Sets the new idle state, if isIdleNow is true, it pings the &#123;@link ResourceCallback&#125;. * @param isIdleNow false if there are pending operations, true if idle. */ public void setIdleState(boolean isIdleNow) &#123; mIsIdleNow.set(isIdleNow); if (isIdleNow &amp;&amp; mCallback != null) &#123; mCallback.··(); &#125;· &#125;&#125; 通过 IdlingResource 来完成异步测试需要三步： 在主工程中创建一个 IdlingResource，并暴露一个获取实例的方法供测试工程调用，可以使用注解 @VisibleForTesting 12345678@VisibleForTesting @NonNull public IdlingResource getIdlingResource() &#123; if (mIdlingResource == null) &#123; mIdlingResource = new SimpleIdlingResource(); &#125; return mIdlingResource; &#125; 在测试工程中调用上方法，将 IdlingResource 注册到系统中 1234567891011121314// 注册@Before public void registerIdlingResource() &#123; mIdlingResource = mActivityRule.getActivity().getIdlingResource(); // To prove that the test fails, omit this call: Espresso.registerIdlingResources(mIdlingResource); &#125;// 反注册@After public void unregisterIdlingResource() &#123; if (mIdlingResource != null) &#123; Espresso.unregisterIdlingResources(mIdlingResource); &#125; &#125; 在主工程中调用下面两个方法完成耗时操作的标记 12idlingResource.setIdleState(false); // 来阻塞测试线程 idlingResource.setIdleState(true); // 来放开测试线程 假设我们使用 processMessage 方法来处理一个耗时操作，内部使用handler，下面是示例代码：123456789101112131415161718192021static void processMessage(final String message, final DelayerCallback callback, @Nullable final SimpleIdlingResource idlingResource) &#123; // The IdlingResource is null in production. if (idlingResource != null) &#123; idlingResource.setIdleState(false); &#125; // Delay the execution, return message via callback. Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; if (callback != null) &#123; callback.onDone(message); if (idlingResource != null) &#123; idlingResource.setIdleState(true); &#125; &#125; &#125; &#125;, DELAY_MILLIS); &#125; Intent相关测试 这里会作为一个专题重点来讲 Base Advance比如 startActivityForResult 这种类型的跳转测试 多窗口测试Android 系统允许多个 View 控件位于系统的最顶层目录上，只是层级不一样，这样会造成有的 View 控件被遮挡导致不可交互，那测试工程通过什么手段能知道当前是哪些 View 控件处理可交互的状态，哪些是不可交到状态呢。 UiAutomator 自动化测试 这个提供了 Android 手机上应用间的自动化测试，它可以很方便的模拟人在使用手机过来中出现的各种操作，并提供了相关的验证方法；UiAutomator 与 Espresso 框架有一个不同的地方在于获取 Context。 InstrumentationRegistry这是一个暴露的注册实例，持有 instrumentation 运行的进程和参数，还提供了一种简便的方法调用 instrumentation, application context 和 instrumentation 参数。它主要用来获取 Context 及 Instrumentation 实例。 注意：自动化测试代码 跟 Android 工程代码实际上没有什么区别，所以在有 Context 的情况下，能做的事情很多，比如关闭打开 Wifi，启动 Activity 应用等等。 12InstrumentationRegistry.getInstrumentation(); // 可用于获取 UiDeviceInstrumentationRegistry.getContext(); // 获取 Context UiDevice这个是 uiautomator 提供的一个操作设备的类，它可以模拟各种设备相关的操作，比如按击Home键，菜单栏等，它包含了大量的 API，具体可以参考上面的文档。 1UiDevice mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation()); By + BySelector + Until这是很实用的一组工具类，三者结合可以用来完成查找或修改及验证（Until类）功能，上面附有对应的文档，可以查阅API，下面介绍一下简单的使用： 12Until.hasObject(By.pkg(pkgName).depth(0)) // 判断 pkgName app 是否在当前手机最上层Until.findObject(By.res(pkgName, "textToBeChanged")) // 查找 pkgName 应用中 id 为 textToBeChanged 的组件 wait 判断测试用例中用来的超时等待，比如我要判断当前某一个应用当前是否在最上层，并且可以设置超时时间，这个 wait的还会返回一个 Object 实体。 12mDevice.wait(Until.hasObject(By.pkg(launcherPackage).depth(0)), 5000);mDevice.wait(Until.hasObject(By.pkg(pkgName).depth(0)), 5000); 下面这个理解一下，wait 操作返回一个 Object，然后获取这个 Object 的内容 该操作相比 mDevice.findObject，只是多加了一个超时等待 1234UiObject2 changedText = mDevice.wait( Until.findObject(By.res(BASIC_SAMPLE_PACKAGE, "textToBeChanged")), 500 ); assertThat(changedText.getText(), is(equalTo("UiAutomator"))); findObject该接口返回一个实体组件，然后再调用对应的方法，入参为包句，及 id1234mDevice.findObject(By.res(BASIC_SAMPLE_PACKAGE, "editTextUserInput")) .setText("UiAutomator");mDevice.findObject(By.res(BASIC_SAMPLE_PACKAGE, "activityChangeTextBtn")) .click(); assertThat 验证12assertThat(mDevice, notNullValue());assertThat(changedText.getText(), is(equalTo("UiAutomator"))); check 方法这里罗列一些常用的check方法：1234check(matches(isDisplayed())); // 检测是否显示状态（可用于 TextView）check(matches(not(isDisplayed()))); // 检测是否非显示状态check(doesNotExist()); // 检测是否可见在当前屏check(matches(isChecked())); // 检测 ToggleButton 是否点击 anyof 接口12345678910onView(withId(R.id.editText)).check( matches( HintMatcher.withHint( anyOf( endsWith(COFFEE_ENDING), endsWith(COFFEE_INVALID_ENDING) ) ) ) ); Espresso cheat sheet 引用 Best Practices for Testing 官方指导说明 测试支持库中文文档 测试框架 API Android Testing Support Library 测试框架 Android Testing Support Library Samples 测试DEMO]]></content>
      <categories>
        <category>android-test</category>
      </categories>
      <tags>
        <tag>as</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN 命令速查]]></title>
    <url>%2F2017%2F03%2F14%2F2017-3-14-svn%2F</url>
    <content type="text"><![CDATA[SVN常用命令速查表 下载代码12svn checkout svn://192.168.1.1/pro/domainsvn co path // 简写 更新代码12svn update // 将当前目录以及子目录下的所有文件都更新到最新版本svn update -r 200 test.java // 将test.java更新到版本200 本地代码回退修改过的东西没有递交，这种情况下revert会取消之前的修改。1svn revert test.java 如果是将路径path下面所有的代码取消修改，需要加上 -R 参数12svn revert -R pathsvn revert // 回退当前目录下的所有文件 线上代码回退如果改动的东西已经提交了，这个时候需要使用merge来处理步骤如下：123456svn update // 确认代码最新svn log test.javasvn log path // 通过log命令获取版本号svn merge -r 20:10 test.javasvn merge -r 20:10 path // 合并修改到本地文件svn ci -m "rollback code" // 提交修改合并上传到线上 解决冲突冲突发生时一般会有如下提示信息:1234Conflict discovered in file 'app\app.iml'.Select: (p) postpone, (df) show diff, (e) edit file, (m) merge, (mc) my side of conflict, (tc) their side of conflict, (s) show all options: 相关的解释如下：123456(p) postpone 暂时推后处理，我可能要和那个和我冲突的家伙商量一番(df) diff-full 把所有的修改列出来，比比看(e) edit 直接编辑冲突的文件(mc) mine-conflict 如果你很有自信可以只用你的修改，把别人的修改干掉(tc) theirs-conflict 底气不足，还是用别人修改的吧(s) show all options 显示其他可用的命令 移除冲突当执行123svn updateC test.javaUpdated to revision 31. 此时工作区会产生三个新文件：12345lstest.javatest.java.minetest.java.r30test.java.r31 当解决了test.java的冲突，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。然后再 commit。 当然也可以仅仅删除冲突的文件并且提交，但是 svn resolved 除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，推荐你使用这个命令。 提交代码12svn add test.java // 往版本库中添加文件svn commit -m "add test file to svn" test.java // 提交修改 加锁/解锁123svn lock -m "lock test file" test.javasvn unlock test.javasvn unlock path 查看文件目录状态12svn status // 查看当前目录下文件及子目录的状态，正常状态不显示svn status path // 查看path目录下文件及子目录的状态，正常状态不显示 相关图标解释如下12345?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定 加参数v后，显示版本号、修改人及文件路径12345svn status -v path // 显示文件和子目录状态（显示所有文件状态）6514 6506 jingtalk .6514 6481 jingtalk androidTest6514 6481 jingtalk androidTest\java6514 6481 jingtalk androidTest\java\com 查找某类修改的情况，比如只查找修改的gradle文件，加上参数 “| grep gradle” 12345svn status | grep gradleM Login\facebooklogin\build.gradle? Samples\IMSDKSample\.gradleM Samples\IMSDKSample\build.gradleM Samples\IMSDKSample\gradle.properties 删除文件12345678svn delete svn://192.168.1.1/pro/domain/test.java -m "delete test file" // 删除svn文件// 或者svn delete test.javasvn ci -m "delete test file"svn delsvn rmsvn remove 查看日志显示这个文件或者目录的所有修改记录，及其版本号的变化12svn log pathsvn log test.java 显示svn最近的5条日志，这个很有用 12svn log --limit 5svn log -l 5 查看文件详细信息显示这个文件或者目录的SVN地址、本地信息、版本、最近修改人及修改记录12svn info pathsvn info test.java 比较差异 对比本地版本与线上版本 12svn diff pathsvn diff test.java 如下，通过+/-号来区分修改1234567891011121314$ svn diff build.gradleIndex: build.gradle===================================================================--- build.gradle (revision 6514)+++ build.gradle (working copy)@@ -50,7 +50,7 @@ leakCanaryVersion = '1.3.1' // Third Channel Libraries- facebookVersion = '4.6.0'+ facebookVersion = '4.20.0' googleVersion = '8.1.0' adjustVersion = "4.11.0" 对比两个版本之前的区别 1svn diff -r 200:201 test.java 合并差异将两个版本之间的差异合并到当前文件1svn merge -r 200:205 test.java SVN 帮助12svn helpsvn help commit SVN list查看path路径下所有属于版本库的文件123456789101112svn list pathsvn ls// 显示当前base目录子目录的svn情况svn ls base.gitignorebase.imlbuild.gradlejni/libs/proguard-rules.prosrc/ 引用SVN命令行模式的操作命令教程(各种SVN命令)]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 使用攻略]]></title>
    <url>%2F2017%2F03%2F06%2F2017-3-6-gradle%2F</url>
    <content type="text"><![CDATA[本文主要讲解一下Gradle的使用方法及注意事项，方便查阅 gradle介绍Groovy会把脚本编译成groovy.lang.Script的子类。groovy.lang.Script是一个抽象类，它有一个抽象方法run(). 如果有一个脚本的文件名是Main，它的内容是：1println 'Hello from Groovy' 它编译后生成的类是：12345678class Main extends groovy.lang.Script &#123; def run() &#123; println 'Hello from Groovy'&#125;static void main(String[] args) &#123; InvokerHelper.runScript(Main, args)&#125; 脚本中的语句会成为run方法的实现。 Gradle脚本编译生成的类当然也继承自groovy.lang.Script，并同时实现了Gradle自己的script接口org.gradle.api.Script。 gradle脚本build过程Gradle脚本的build流程分为3个阶段： 初始化阶段Gradle支持单个和多个工程的编译。在初始化阶段，Gradle判断需要参与编译的工程，为每个工程创建一个Project对象，并建立工程之间的层次关系。这个阶段执行Settings脚本。 配置阶段Gradle对上一步创建的Project对象进行配置。这个阶段执行Build脚本 执行阶段Gradle执行选中的task。 settings.gradle这个文件是全局的项目配置文件，里面主要声明一些需要加入 gradle 的 module；此处包含了所有参与工程编译的 Module。 用于初始化project树。 123include ':app', ':base'include ':volley'include ':wechatauth' include语法groovy允许省略语句结尾的分号，并允许在方法调用时省略括号。下面两行代码等价。12include ':app', ':mylibrary'include(':app', ':mylibrary'); 初始化脚本的Script对象会有一个Project代理对象。在Script对象没有定义的属性和方法调用就会被转到Project对象。上面的语句实际上调用的是Project对象的include方法，该方法的原型如下：1void include(String[] projectPaths) 这个方法将给定的工程添加到build中。工程路径的格式是:以一个可选的”:”的开始，它表示”:”前面有一个不需要名字的根工程；剩下的部分是以”:”分隔的工程名。例如， “:app”中”:”的是可选的，它表示”:”前面有一个不需要名字的根工程。 运行”gradle projects”可以获得这个demo的project树:123Root project 'AndroidDemo' //工程名+--- Project ':app'\--- Project ':modulename' local.propertiesgradle的SDK和NDK环境变量配置12345678910## This file is automatically generated by Android Studio.# Do not modify this file -- YOUR CHANGES WILL BE ERASED!## This file should *NOT* be checked into Version Control Systems,# as it contains information specific to your local configuration.## Location of the SDK. This is only used by Gradle.# For customization when using a Version Control System, please read the# header note.sdk.dir=E\:\\Android\\android-sdk-windows gradle.properties设置gradle脚本中的参数，比如代理1234567891011121314151617181920## Project-wide Gradle settings.## For more details on how to configure your build environment visit# http://www.gradle.org/docs/current/userguide/build_environment.html## Specifies the JVM arguments used for the daemon process.# The setting is particularly useful for tweaking memory settings.# Default value: -Xmx1024m -XX:MaxPermSize=256m# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8## When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=true#Thu Feb 23 20:37:17 CST 2017systemProp.https.proxyPort=8080systemProp.http.proxyHost=dev-proxy.oa.comorg.gradle.jvmargs=-Xmx1536msystemProp.https.proxyHost=dev-proxy.oa.comsystemProp.http.proxyPort=8080 build/gradle/wrapper/gradle-wrapper.propertites声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，有時候导入一个新项目，gradle版本不对，可以在这里修改。123456#Mon Dec 28 10:00:20 PST 2015distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip build.gradle[project]这个文件是整个项目的gradle基础（全局）配置文件，内容主要包含了3个方面： 一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。 另一个是声明了android gradle plugin的版本。 allprojects:中定义的属性会被应用到所有 moudle 中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。 1234567891011121314151617181920212223// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 所有通过gradle导入的jar包都是从jcenter这个中央仓库上扒下来的。 如果你需要的jar包在这个网站上没有，那就无法通过gradle的方式来导入的。 ext定义全局属性根目录的gradle文件，在module比较多的情况下，最好统一，可以在这个文件定义一些共用的属性，然后在子module中。 123456789//全局配置ext &#123; minSdkVersion =15 targetSdkVersion =24 compileSdkVersion =24 buildToolsVersion ="24.0.0" versionCode =1 versionName="1.0"&#125; 然后在子Module的gradle文件中引用123456789101112android &#123; compileSdkVersion rootProject.ext.compileSdkVersion buildToolsVersion rootProject.ext.buildToolsVersion defaultConfig &#123; minSdkVersion rootProject.ext.minSdkVersion targetSdkVersion rootProject.ext.targetSdkVersion versionCode rootProject.ext.versionCode versionName rootProject.ext.versionName testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125;&#125; ext定义全局属性列表123456789ext &#123; channelDespendencies = [ facebook: "com.facebook.android:facebook-android-sdk:$&#123;facebookVersion&#125;", googleAuth: "com.google.android.gms:play-services-auth:$&#123;googleVersion&#125;", googleGames: "com.google.android.gms:play-services-games:$&#123;googleVersion&#125;", googleGCM : "com.google.android.gms:play-services-gcm:$&#123;googleVersion&#125;", googleGCM : "com.google.android.gms:play-services-gcm:$&#123;googleVersion&#125;", ]&#125; 子module中引用如下12345dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') compile rootProject.ext.channelDespendencies.facebook compile project(':base')&#125; def定义全局函数在根目录的全局gradle文件中定义函数 不包含在ext大标签下面 123456789def releaseTime() &#123; return new Date().format("yyyy-MM-dd-HH", TimeZone.getTimeZone("UTC"))&#125;def svnVersion(String url)&#123; def svnUrl = "test"; String result = "svn info --show-item last-changed-revision $&#123;svnUrl&#125;".execute().text return Integer.parseInt((result.trim()!="")? result.trim() : "1")&#125; 子module引用123456789101112android &#123; compileSdkVersion rootProject.ext.androidCompileSdkVersion buildToolsVersion rootProject.ext.androidBuildToolsVersion defaultConfig &#123; minSdkVersion rootProject.ext.androidMinSdkVersion targetSdkVersion rootProject.ext.androidTargetSdkVersion versionCode rootProject.svnVersion("facebooklogin") // look here versionName mVersionName &#125; &#125; build.gradle[Module:app]这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件，比如自动打包debug，release，beta等环境，签名，多渠道打包，混淆等操作都可以在这里面写。 build.gradle[Module:xxx]每一个Module都需要有一个gradle配置文件。 引用Gradle语法及Build过程]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS 中 Butter Knife 使用详解]]></title>
    <url>%2F2017%2F01%2F18%2F2017-1-18-butterknife%2F</url>
    <content type="text"><![CDATA[介绍开源注入框架 Butter Knife 的使用方法 AUTHOR: jingtalk DEMO: jingtalk/Hello-ButterKnife Butter Knife介绍官方Git地址官网使用说明Android开发中大量的findViewById和点击事件，像初始view、设置view监听这样简单而重复的操作让人觉得特别麻烦，这个时候就有了相应的偷懒文案-依赖注入。目前比较流行的两种 ButterKnife 和 Dagger:而Dagger中View的注入写法非常困难或者难懂，这个时候 ButterKnife 诞生了，所以直接叫 ButterKnife 为 findViewById 都是没有问题的。 Butter Knife的特点： 强大的View绑定和Click事件处理功能，简化代码，提升开发效率 方便的处理Adapter里的ViewHolder绑定问题 运行时不会影响APP效率，使用配置方便 代码清晰，可读性强 AS配置在module的build.gradle文件中添加如下代码 最新版本信息请在官网使用说明中查询 1234dependencies &#123; compile 'com.jakewharton:butterknife:8.4.0' annotationProcessor 'com.jakewharton:butterknife-compiler:8.4.0'&#125; 即可； 绑定View、资源下面这些绑定操作在 ButterKnife.bind(this) 后执行相应id与view的绑定，要注意的是，这一行代码必须在 setContentView 之后，否则会有异常发生； Butter Knife 支持下面这些绑定操作，对于View的绑定，相当于findViewById操作；对于资源绑定，相当于已经初始化，取值为对应的values资源 或者 图片文件。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// View绑定@BindView(R.id.tvWorld)TextView tvWorld;@BindView(R.id.tvChina)TextView tvChina;@BindView(R.id.tvShenZhen)TextView tvShenZhen;// 资源绑定@BindArray(R.array.arrayTest)String[] arrays;@BindColor(R.color.colorTest)int colorValue;@BindString(R.string.stringTest)String stringValue;@BindBitmap(R.mipmap.avator_one)Bitmap avatorOne;@BindDrawable(R.mipmap.avator_two)Drawable avatorTwo;@BindBool(R.bool.boolTest)boolean bool;@BindDimen(R.dimen.dimenTest)int dimen; // int (for pixel size) or float (for exact value) field@BindInt(R.integer.intTest)int intValue;// 可绑定 float 类型的 dimen 资源 - 待验证// @BindFloat(R.dimen.floatTest)// float floatValue;// 批量绑定@BindViews(&#123;R.id.tvWorld, R.id.tvChina, R.id.tvShenZhen&#125;)List&lt;TextView&gt; tvList;@BindView(R.id.ivBitmap)ImageView ivBitmap;@BindView(R.id.ivDrawable)ImageView ivDrawable; 使用情况如下：12345678910111213141516protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); Log.d(TAG, "onCreate called, bool=" + bool + ", dimen=" + dimen + ", intValue=" + intValue + ", stringValue=" + stringValue + ", arrays=" + arrays.toString()); tvShenZhen.setText(stringValue); tvShenZhen.setTextColor(colorValue); tvList.get(0).setText(arrays[0]); ivBitmap.setBackground(avatorTwo); ivDrawable.setBackground(new BitmapDrawable(avatorOne));&#125; 绑定Fragment在onCreateView中使用12345678910111213141516171819202122232425262728@BindView(R.id.id_title_left_btn)ImageButton mLeftMenu;@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_title, container, false);/* mLeftMenu = (ImageButton) view.findViewById(R.id.id_title_left_btn); mLeftMenu.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getActivity(), "i am a imagebutton in TitleFragment!", Toast.LENGTH_LONG).show(); &#125; &#125;);*/ // Fragment中的绑定操作 ButterKnife.bind(this, view); return view;&#125;@OnClick(R.id.id_title_left_btn) public void show() &#123; Toast.makeText(getActivity(), "i am a imagebutton in TitleFragment!", Toast.LENGTH_LONG).show();&#125; 绑定Adapter主要是创建ViewHolder的方式不一样，代码逻辑在getView中完成。标准写法123456public final class ViewHolder &#123; public ImageView img; public TextView title; public TextView info; public Button viewBtn;&#125; 标准用法123456789101112131415161718192021222324252627@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.list_item, null); holder.img = (ImageView) convertView.findViewById(R.id.img); holder.title = (TextView) convertView.findViewById(R.id.title); holder.info = (TextView) convertView.findViewById(R.id.info); holder.viewBtn = (Button) convertView.findViewById(R.id.view_btn); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.img.setBackgroundResource((Integer) mData.get(position).get("img")); holder.title.setText((String) mData.get(position).get("title")); holder.info.setText((String) mData.get(position).get("info")); holder.viewBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; showInfo(); &#125; &#125;); return convertView;&#125; Butter knife的写法12345678910111213141516171819public final class ViewHolderBK &#123; @BindView(R.id.img) ImageView img; @BindView(R.id.title) TextView title; @BindView(R.id.info) TextView info; @BindView(R.id.view_btn) Button viewBtn; public ViewHolderBK(View view) &#123; ButterKnife.bind(this, view); &#125; @OnClick(R.id.view_btn) public void show() &#123; showInfo(); &#125;&#125; Butter knife的写法123456789101112131415@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolderBK holder = null; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.list_item, null); holder = new ViewHolderBK(convertView); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolderBK) convertView.getTag(); &#125; holder.img.setBackgroundResource((Integer) mData.get(position).get("img")); holder.title.setText((String) mData.get(position).get("title")); holder.info.setText((String) mData.get(position).get("info")); return convertView;&#125; 对比发现，会简洁很多。 OnClick、OnLongClick绑定支持可变参数的函数，并能批量绑定处理1234567891011121314151617181920212223242526272829303132333435@OnClick(&#123;R.id.ivBitmap, R.id.ivDrawable&#125;)public void sayHiToast(View v) &#123; switch (v.getId()) &#123; case R.id.ivBitmap: Toast.makeText(getApplicationContext(), "ivBitmap click", Toast.LENGTH_SHORT).show(); break; case R.id.ivDrawable: Toast.makeText(getApplicationContext(), "ivDrawable click", Toast.LENGTH_SHORT).show(); break; &#125;&#125;@OnClick(R.id.btnLogin)public void doLogin() &#123; Toast.makeText(getApplicationContext(), "doLogin click", Toast.LENGTH_SHORT).show();&#125;@OnLongClick(R.id.btnLogin)public boolean doLogin(Button button) &#123; button.setText("Login update"); return true;&#125;@OnClick(R.id.btnCancel)public void doCancel(Button button) &#123; Toast.makeText(getApplicationContext(), "doCancel click", Toast.LENGTH_SHORT).show(); button.setText("Error");&#125;// 自定义View的话，绑定自己的监听，不需要指定 IDpublic class JingButton extends Button &#123; @OnClick public void onClick() &#123; &#125;&#125; 其它监听器绑定Butter Knife还支持下面这些监听器操作 实际上，BK对该类型的回调函数的写法有一定的要求，如返回值或者参数等，这个具体问题具体对待，从直观的做法是直接看源码的注释，如下所示： 可选绑定默认情况下，如果找不到目标视图，则会抛出异常使用 @Optional,存在即绑定，不存在即忽略，不抛异常12345@Optional @OnClick(R.id.fab)public void make(View view) &#123; Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG) .setAction("Action", null).show();&#125; ButterKnife.findById()强转ButterKnife.findById()自动强转，第一个参数可为 View, Activity, Dialog，使用如下：1234View view = LayoutInflater.from(context).inflate(R.layout.thing, null);TextView firstName = ButterKnife.findById(view, R.id.first_name);TextView lastName = ButterKnife.findById(view, R.id.last_name);ImageView photo = ButterKnife.findById(view, R.id.photo); Binding Reset操作Fragments 有比Avtivity更多的生命周期 ，如果需要在onCreateView中注入一个fragment，在onDestroyView中销毁它Butter Knife 有一个reset 方法自动实现它1234567891011121314151617181920// 定义一个变量并通过bind操作获得返回值private Unbinder unbinder;@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_title, container, false); // Fragment中的绑定操作 unbinder = ButterKnife.bind(this, view); return view;&#125;@Overridepublic void onDestroyView() &#123; super.onDestroyView(); // 解绑操作 unbinder.unbind();&#125; ButterKnife.apply使用Zelezny插件使用如果还想偷懒的话，可以在AndroidStudio-&gt;File-&gt;Settings-&gt;Plugins-&gt;搜索Zelezny插件下载使用, 它可以快速生成对应组件的实例对象，不用手动写。使用时，在要导入注解的Activity 或 Fragment 或 ViewHolder的layout资源代码上，右键—&gt;Generate—&gt;Generate ButterKnife Injections，然后就出现如图的选择框，在里面可以选择相应的事件并自动生成。 引用文章 绝对不容错过，ButterKnife使用详谈 ButterKnife使用详解 ButterKnife基本使用]]></content>
      <categories>
        <category>andoird-osl</category>
      </categories>
      <tags>
        <tag>butterknife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题汇总]]></title>
    <url>%2F2017%2F01%2F12%2F2017-1-12-interview-problem%2F</url>
    <content type="text"><![CDATA[WearSport GPS打点数据爆表打点采样优化动画卡顿 PhoneSport View绘制 WatchMusicPlayer 三方框架实现第三方音乐适配表盘控制 Unity3D NGUINetworkView 快鸟 启动页优化跳出率是指在只访问了入口页面（例如网站首页）就离开的访问量与所产生总访问量的百分比启动页优化策略 引导页优化 MIUI项目组 Token刷新流量查询CDN加速偷跑流量加速效果不理想 秀吧 音视频上行预研Android终端设备视频直播上行发布 方案1：视频采集 + RTMP 视频采集方法可二选一， Android版本的RTMP协议有多种开源实现，常用的有下面三种： RED5：比较主流开源实现，网上有对应的开源project实现 android-recorder，这个版本的实现要求客户端与服务器端的RTMP版本兼容，否则客户端在连接成功后在开始创建流的时候，服务端把连接断开了，这个已在我们自己的服务器上验证，是匹配的; 国内开源project中采用的 android-rtmp-client，它是上面red5的精简版，编码上没有前者这么麻烦，存在的问题同上; 国外收费的rtmpclient，申请注册码或者进行破解，这个已有牛人提供了破解教程，并且提供下载，可以直接使用，这个有待验证。 方案2：视频采集 + ffmpeg + RTMP（待测） FFMPEG在linux、windows平台上运行良好，能进行视频采集，编解码、播放以及流化能力，但在Android平台，使用最多的还它的播放、编解码能力。而视频采集一般使用已介绍的二种方式，目前要探究的课题是在Android平台，如何通过ffmpeg来发布视频。 FFMPEG是支持RTMP协议的，所以在linux/windows平台能通过以下方式来发布视频，实现直播。1ffmpeg -t 10 -f video4linux2 -s 176*144 -r 8 -i /dev/video0 -vcodec h263 -f rtp rtp://192.168.1.105:5060 &gt; /tmp/ffmpeg.sdp 目前Android上的ffmpeg移植也有很多参考材料，但甚少提及其发布功能，这部分需要深入阅读ffmpeg的源码，才能看到其流化接口，然后再发布。 视频采集前后摄像头可以正常切换，目前是通过前置摄像头来采集数据 Camera + PreviewCallback（Interface） 所采集的视频数据一般在PreviewCallback 的实现函数中获取。 public void onPreviewFrame(byte[] data, Camera camera) 该data数据为YUV格式的原始视频帧数据，一般为YUV420SP，这里要完成 yuv-&gt;rgb-&gt;视频流的转化过程（这块儿的具体过程还并不非常清晰） 并且音视频数据是没有经过编码处理的，此处可以使用第三方编码库来处理，如果ffmpeg、或者x264、AAC编码后再发布 Camera + MediaRecorder 通过MediaRecorder获取的视频数据是已经编码过后的数据，在获取视频数据之前可以指定音视频编码格式，输出格式 支持 本地存储 + 远程输出 视频播放由于目前的Android秀吧终端是能进行视频下行直播的，用的是ffmpeg，关于播放，此处不考虑 视频发布RTMP 方法1：开源red5 demo1视频采集使用mediarecorder， 目前按照 RTMP协议，以下流程能正常走通 1&gt;Client→Server :发送一个与流媒体服务器建立连接的请求.2&gt;Server→Client : 服务器确认建立连接3&gt;Client→Server : 发送一个创建流的请求4&gt;Server→Client :服务器确认流请求，并返回一个表示流的索引号.5&gt;Client→Server :提交一个发布数据的请求6&gt;Server→Client ：服务器确认数据发布请求7&gt;Client→Server :发送视音频数据包(这些包在同一个频道(channel)并用流的索引号来唯一标识). 问题：demo在完成视频录制以后，再将视频发到服务器，在上面的第7步中，视频发布以后，服务器的解包有问题，定位应该是RTMP视频打包有问题，目前想把这一整套流程走通。 后面再实时发包看看视频效果 方法2：开源red5精简版 android-rtmp-client 面临的问题同上 方法3：rtmpclient破解版 demo2视频采集使用 PreviewCallback， rtmp使用破解版的rtmpclient 1&gt; RTMP 2&gt; FFMPEG Android机顶盒 Setting、Framework定制Launcher开发、焦点框特效重绘、滑动延时、按键屏蔽设备主控、界面提示框升级、JAVA/C同步]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 应用启动时序图]]></title>
    <url>%2F2017%2F01%2F11%2F2017-1-11-android-start%2F</url>
    <content type="text"><![CDATA[Android应用程序启动过程]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载说明]]></title>
    <url>%2F2017%2F01%2F08%2F2017-1-8-class-loader%2F</url>
    <content type="text"><![CDATA[类加载器介绍 Dex文件格式]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KeyPoint 博文收录]]></title>
    <url>%2F2016%2F12%2F26%2F2016-12-26-key-index%2F</url>
    <content type="text"><![CDATA[不重复造轮子，这里收录一些经典知识点的博文讲解 开源库 Android通用流行框架大全 Universal Image Loader原理 RxJava 详解 View View 事件传递 View 绘制流程 Android 动画基础 ViewStub原理及用法 Acitivty Activity四种启动模式 singleTask和singleInstance区别 Activity启动过程详解1 Activity启动过程详解2 Android应用启动时序图 进程/线程/保活 进程保活方案 Android Service 保活 Handler机制详解 IPC通讯 彻底了解Binder机制原理和底层实现 注解 Java 注解 Annotation Dagger 源码解析 Android Studio 中Butter Knife使用详解 ButterKnife和Dagger的简单比较 Dagger、RoboGuice和ButterKnife 反射、代理 依赖注入说明 Java动态代理1 Java动态代理2 Java反射说明 插件化 蘑菇街Android组件与插件化1 蘑菇街Android组件与插件化2 Android插件化原理解析-系列 Qihoo360 DroidPlugin Android动态加载那些事儿 DL动态加载框架技术文档 类加载说明-PathClassLoader/DexClassLoader 插件化开发—动态加载技术加载已安装和未安装的apk - ClassLoader使用 ANDROID 动态加载系列索引 - Kaedea CLASSLOADER 的工作机制 - Kaedea 插件化-代理 ACTIVITY 模式 - Kaedea 插件化-动态创建 ACTIVITY 模式 - Kaedea Android热补丁动态修复技术 - Altsuki Android中的动态加载机制 - 尼古拉斯 Android中插件开发篇之—类加载器 - 尼古拉斯 Android中插件开发篇之—应用换肤原理解析 - 尼古拉斯 Android中插件开发篇之—动态加载Activity(免安装运行程序) - 尼古拉斯 Android常识点 App监控自身的崩溃 APK安装过程及原理 如何开发一个App AsyncTask AsyncTask 使用和缺陷 老罗的Android之旅 Android应用程序的Activity启动过程 Android应用程序进程启动过程的源代码分析 Android高工必备技能 android-support-multidex解决Dex 65536 Android产品研发系列 Android开发规范 实用开发规范 Java 单例模式 Java 单例真的写对了么? JAVA四种引用方式 java volatile详解 Java并发编程：volatile关键字解析 java synchronized详解 java包类接口修饰符 Java Class文件格式讲解1 Java Class文件格式讲解2 java值传递和引用传递 虚拟机 Android开发——JVM、Dalvik以及ART的区别 Dalvik和ART运行时环境的区别 Linux/C 字符编码通俗讲解 堆与栈区别 String、StringBuffer与StringBuilder之间区别 C/C++程序编译过程详解 网络 HTTP协议详解 深入理解HTTP协议 HTTP应答状态 HTTP Cookie解读 TCP三次握手四次挥手图解1 TCP三次握手四次挥手讲解2 OSI七层与TCP/IP五层网络架构 算法 结构之法算法之道 - july 剑指offer - 何海涛 牛客网 算法-排序 算法-链表 算法-树 算法-递归、栈、字符串]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-design-mode%2F</url>
    <content type="text"><![CDATA[UML 类：抽象类用斜体表示 接口：&lt;&gt; 或者棒棒糖表示法 继承：空心三角形+实线 实现：空心三角形+虚线 关联：当一个类知道另一个类时，可以用关联，实线箭头 聚合：表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分，空心的菱形+实线箭头 合成：表示一种强的“拥有”关系，体现了严格的部分和整体关系，部分和整体的生命周期一样，实心的菱形+实心箭头 依赖：虚线箭头 创建型社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是： 简单工厂模式如何去实例化对象的问题，考虑用一个单独的类来做这个创建实例的过程（该工厂类中多有switch或if结构来接受用户输入的参数，进而实例化不同的实例返回）所有在用到简单工厂的地方，都可以考虑反射来去除switch或if，解决分支判断带来的耦合。（反射可以利用字符串来实例化对象，而变量是可以更换的 — 反射 + 配置文件）Tips：新修改来时，除了创建必要的子类之外，还需要修改简单工厂类，对修改开放。不需要修改客户端（传入的参数改变而已） 工厂方法模式FactoryMethod 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。与简单工厂的区别：简单工厂类派生了很多子工厂 ，每个工厂子类类（有共同的父类）对应于一个实例的初始化过程。因此原来在简单工厂类中switch和if结构被去除。只需要在客户端中创建指定的工厂来实例化指定的类即可。Tips：工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，只是工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行，你想加功能，本来是改工厂类的，而现在是修改客户端 抽象工厂 方法模式Abstract Factory 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类与工厂方法的区别：每个工厂类（有共同的父类工厂）处理的对象多于一个时，即每个工厂子类中要实例化多于一个的对象时。Tips：抽象工厂方法模式非常便于交换产品系统；客户端通过它们的抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中 单例模式Singleton 保证一个类仅有一个实例，并提供一个访问它的全局访问点所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示的构造方法，默认的构造方法就会失效。若把类的构造方法写成private的，那么外部程序就不能用new来实例化它了Tips：因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它，简单地说就是对唯一实例的受控访问。 建造者模式Builder 将一个复杂对象的构建与它的表示分离，使得同样的构造过程可以创建不同的表示创建的过程是人稳定的，而具体创建的细节是不同的（小人 vs 胖小人），使用了该模式以后，用户只需要指定的需要创建的类型就可以得到他们，而具体建造的过程和细节就不需要知道了。Tips：当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用，好处是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以或需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。 原型模式Prototype 用原型实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象（JAVA 与 .NET都有对应的接口实现）从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。一般在初始化的信息不发生改变的情况下，克隆是最好的方法，这既隐藏了对象创建的细节，又对性能是大的提高。它相当于不用重新初始化对象，而是动态的获得对象的运行时的状态。（浅复制：被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其它对象的引用都仍然指向原来的对象）（深复制：与上面的区别在于，深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象）Tips：当创建实例的过程非常昂贵时适用]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一般产品流程]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-pm-process%2F</url>
    <content type="text"><![CDATA[转载 产品从无到有，从一个想法到雏形到上线的产品，都有个过程。不论是产品、运营、开发、测试等都有自己的职责和工作。很多公司都希望将自己的产品流程化，正规化，希望按照一定的流程走下去，想的是哪天哪个职位出现空缺了，直接找个合适的人可以顶替。同时也为以后的产品工作或项目进程都提供一个模版。特别是对于中小型公司来说，当没有UED，当没有产品相关流程时，产品是否能够按时完成，能否高质量的完成，成为很多产品经理和BOSS担忧的事情。 结合自己的产品经验，同时在不同的公司的经历，将产品流程规划分为8个阶段：立项阶段、设计阶段、开发阶段、测试阶段、上线阶段、磨合阶段、运营阶段、总结阶段。 立项阶段体现产品经理核心功能的阶段，对于产品需求确定，核心功能提炼。产品提出讨论，输出MRD，与技术、业务、资源的可用性，同时确定产品参与人员，沟通是产品经理的一项职能，如何将所有的参与人员集合一起共事，如何更有效的沟通，明确各自的职责。更希望将产品聚焦于可以满足80%用户需求的解决方案，而非20%的用户需求。 设计阶段设计阶段的首要任务就是将产品周期确认，周期是产品经理需与各部门人员配合确定的。产品、交互、UI、视觉、开发、测试等人员在设计阶段更多的是个溶合过程，信息的溶合，目的的明确，同时对于各自工作的明确。产品经理在做出PRD后更多的是与其他人员中的交流与沟通，同时文档的迭代，这个阶段是让所有的人员知道这个产品的核心及功能，交互根据文档出高保真原型，UI根据文档找到产品的表现形式，开发知道产品的核心力体现在哪，技术难题以及实现方式等，测试除了了解产品外对于产品的测试重点及难点掌握。运营则知道这个产品亮点及产品特征等，“好产品是运营出来的”，越早让运营介入产品只有好处。 开发阶段“工欲善其事，必先利其器”。从服务器的部署开始，到最后的代码存档迭代，都将是开发人员做为主导的阶段，同时对于产品开发周期的确定。产品经理更多的协助开发了解产品功能，测试需配合开发做单元测试、压力测试等。运营则是更多的是配合内容数据的提供。 测试阶段当产品经历过初审，接下来的工作就交给了测试，黑盒、白盒测试，以及三轮产品测试。第一轮测试发现产品bug，第二轮测试围绕着bug、以及优化展开，经过第三轮测试过后产品已经归类为较稳定版本。在三轮测试中测试人员需时刻保持着沟通协作，与技术、产品、UI等，这是个磨合的过程，同时也是质量把关过程。 上线阶段这也是beta阶段，这也是开启产品市场的阶段。但在上线前需对产品的代码、系统接口监控、系统维护方案、数据清理等，上线评估阶段需经过市场、产品、运营、开发、测试等对于上线做出整体评估后才能正式上线运营。同时对于上线后的跟踪，日志分析、服务器监控等，同时从日志分析出做出产品调整同时产品运营计划表制定。 磨合阶段经过上线阶段的数据分析，以及数据日志的分析，程序等调整，对于产品做出优化，对于用户常见的问题及反馈做出调整，这阶段更多的是产品与用户的磨合，做到更好的用户体验。 运营阶段软文？广告？产品上线后的工作都将是围绕着用户展开的，如何让用户第一时间用上产品，如何让用户知道产品，如何抓住用户……提供优秀的用户体验，让用户喜欢上产品，爱上产品，离不开产品，这是运营的能力，同时也是运营人员对产品的信任，同时应证一句话“好产品是运营出来的”。为用户提供产品帮助，软件产品更多的是产品使用说明书，而web更多的是FAQ，减少用户“为什么”。 总结阶段学会总结，学会分析，学会批评，产品上线后需要对产品做出个阶段的总结，不论是产品上的，还是人员相互配合上的，有摩擦，有不同的见解在产品过程中是常见的，但出发点一定是围绕着产品，提出意见，产品二期改进及规划，这都可以做为总结阶段讨论的重点，以及如何加强沟通协作，如何做好产品运营。产品流程并不是一尘不变的，同时对于不同的产品，会有不同的要求。这样的流程同样适用于做项目，对于很多公司没有UED等组织时，如何高效、快捷的做出产品或完成项目，减少不必要的工作，成为流程简化与规范的基础。8个阶段的相关人员都有相关的侧重点，或许期间还有不同的人员介入，比如市场，比如BOSS，任何一个过程都有可能受到影响 ，这时候需要的是配合、需要的是协作。成功的产品会遇到很多的困难与阻碍，但相信自己的产品只是满足80%用户需求的解决方案，别想100%的压力，没有人会为这100%买单的。]]></content>
      <tags>
        <tag>PM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 面试搜罗]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-android-interview%2F</url>
    <content type="text"><![CDATA[同事，leader，朋友、网上碰到的一些面试问题 开机流程 activity启动流程 binder机制 View绘制 应用怎么监控自己的anr跟crash 内存优化 内存泄漏场景 View的自定义属性 进程保活 app应用安装流程 挑一个系统service讲解/service种类 应用程序启动的时候默认启动几个线程 设计一个错误码处理模块 电梯算法 省电 实现XML解析器 数据库事务为什么性能比较好 多线程并发的时候会有什么权限问题 sharedpreference实现机制 能不能多进程 主题切换 jce是什么 viewStub原理 插件实现 事件分发 Unicode与UTF8区别及怎么编码的 http与tcp的区别 https是什么？cookie是什么？cookie能不能在网上传输？ android6.0的权限管理怎么实现的 Android内存回收顺序]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-其它]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-arithmetic-other%2F</url>
    <content type="text"><![CDATA[递归思想观察递归，我们会发现，递归的数学模型其实就是归纳法，这个在高中的数列里面是最常用的了。回忆一下归纳法。 归纳法适用于想解决一个问题转化为解决他的子问题，而他的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是递归结束的哪一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则我们就无穷递归了。这里又引出了一个归纳终结点以及直接求解的表达式。 如果运用列表来形容归纳法就是： 步进表达式：问题蜕变成子问题的表达式 结束条件：什么时候可以不再是用步进表达式 直接求解表达式：在结束条件下能够直接计算返回值的表达式 逻辑归纳项：适用于一切非适用于结束条件的子问题的处理，当然上面的步进表达式其实就是包含在这里面了。这样其实就结束了，递归也就出来了。 递归算法的一般形式：12345678910void func( mode)&#123; if(endCondition)&#123; constExpression //基本项 &#125; else&#123; accumrateExpreesion /归纳项 mode=expression //步进表达式 func(mode) / /调用本身，递归 &#125;&#125; 一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进;当边界条件满足时，递归返回。注意： (1) 递归就是在过程或函数里调用自身; (2) 在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。 递归应用递归算法一般用于解决三类问题： (1)数据的定义是按递归定义的。（Fibonacci函数） (2)问题解法按递归算法实现。（回溯） (3)数据的结构形式是按递归定义的。（树的遍历，图的搜索） 递归的缺点递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。停止的位置称为 基线条件（base case）。基线条件是递归程序的最底层位置，在此位置时没有必要再进行操作，可以直接返回一个结果。所有递归程序都必须至少拥有一个基线条件，而且必须确保它们最终会达到某个基线条件；否则，程序将永远运行下去，直到程序缺少内存或者栈空间。 颠倒栈题目：用递归颠倒一个栈。例如输入栈{1, 2, 3, 4, 5}，1在栈顶。颠倒之后的栈为{5, 4, 3, 2, 1}，5处在栈顶。我们再来考虑怎么递归。我们把栈{1, 2, 3, 4, 5}看成由两部分组成：栈顶元素1和剩下的部分{2, 3, 4, 5}。如果我们能把{2, 3, 4, 5}颠倒过来，变成{5, 4, 3, 2}，然后在把原来的栈顶元素1放到底部，那么就整个栈就颠倒过来了，变成{5, 4, 3, 2, 1}。接下来我们需要考虑两件事情：一是如何把{2, 3, 4, 5}颠倒过来变成{5, 4, 3, 2}。我们只要把{2, 3, 4, 5}看成由两部分组成：栈顶元素2和剩下的部分{3, 4, 5}。我们只要把{3, 4, 5}先颠倒过来变成{5, 4, 3}，然后再把之前的栈顶元素2放到最底部，也就变成了{5, 4, 3, 2}。至于怎么把{3, 4, 5}颠倒过来……很多读者可能都想到这就是递归。也就是每一次试图颠倒一个栈的时候，现在栈顶元素pop出来，再颠倒剩下的元素组成的栈，最后把之前的栈顶元素放到剩下元素组成的栈的底部。递归结束的条件是剩下的栈已经空了。 这种思路的代码如下：12345678910template&lt;typename T&gt; void ReverseStack(std::stack&lt;T&gt;&amp; stack)&#123; if(!stack.empty()) &#123; T top = stack.top(); stack.pop(); ReverseStack(stack); AddToStackBottom(stack, top); &#125;&#125; 我们需要考虑的另外一件事情是如何把一个元素e放到一个栈的底部，也就是如何实现AddToStackBottom。这件事情不难，只需要把栈里原有的元素逐一pop出来。当栈为空的时候，push元素e进栈，此时它就位于栈的底部了。然后再把栈里原有的元素按照pop相反的顺序逐一push进栈。注意到我们在push元素e之前，我们已经把栈里原有的所有元素都pop出来了，我们需要把它们保存起来，以便之后能把他们再push回去。我们当然可以开辟一个数组来做，但这没有必要。由于我们可以用递归来做这件事情，而递归本身就是一个栈结构。我们可以用递归的栈来保存这些元素。 基于如上分析，我们可以写出AddToStackBottom的代码：123456789101112131415// Add an element to the bottom of a stack:template&lt;typename T&gt; void AddToStackBottom(std::stack&lt;T&gt;&amp; stack, T t)&#123; if(stack.empty()) &#123; stack.push(t); &#125; else &#123; T top = stack.top(); stack.pop(); AddToStackBottom(stack, t); stack.push(top); &#125;&#125; 素数返回100以内的素数个数问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct prime_number_node&#123; int prime_number; prime_number_node* next;&#125;;int calc_prime_number()&#123; prime_number_node* list_head = new prime_number_node(); list_head-&gt;next = NULL; list_head-&gt;prime_number = 2; prime_number_node* list_tail = list_head; for(int number = 3 ; number &lt; 100 ; number++) &#123; int remainder; prime_number_node* cur_node_ptr = list_head; while(cur_node_ptr != NULL) &#123; remainder = number%cur_node_ptr-&gt;prime_number; if(remainder == 0) &#123; //1 break; &#125; else &#123; //2 cur_node_ptr = cur_node_ptr-&gt;next; &#125; &#125; if(remainder != 0) &#123; prime_number_node* new_node_ptr = new prime_number_node(); new_node_ptr-&gt;prime_number = number; new_node_ptr-&gt;next = NULL; list_tail-&gt;next = new_node_ptr; //3 list_tail = list_tail-&gt;next; &#125; &#125; int result = 0; while(list_head != NULL) &#123; result++; prime_number_node* temp_ptr = list_head; list_head = list_head-&gt;next; //4 delete temp_ptr; &#125; return result;&#125; 这里 直接 求 list_head 和 list_tail 的差即可 字符串的排列题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则输出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。我们以三个字符abc为例来分析一下求字符串排列的过程。首先我们固定第一个字符a，求后面两个字符bc的排列。当两个字符bc的排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列。现在是把c放到第一位置的时候了。记住前面我们已经把原先的第一个字符a和后面的b做了交换，为了保证这次c仍然是和原先处在第一位置的a交换，我们在拿c和第一个字符交换之前，先要把b和a交换回来。在交换b和a之后，再拿c和处在第一位置的a进行交换，得到cba。我们再次固定第一个字符c，求后面两个字符b、a的排列。 既然我们已经知道怎么求三个字符的排列，那么固定第一个字符之后求后面两个字符的排列，就是典型的递归思路了。12345678910111213141516171819202122232425262728void Permutation(char* pStr, char* pBegin)&#123; if(!pStr || !pBegin) return; // if pBegin points to the end of string, // this round of permutation is finished, // print the permuted string if(*pBegin == '\0') &#123; printf("%s\n", pStr); &#125; // otherwise, permute string else &#123; for(char* pCh = pBegin; *pCh != '\0'; ++ pCh) &#123; // swap pCh and pBegin char temp = *pCh; *pCh = *pBegin; *pBegin = temp; Permutation(pStr, pBegin + 1); // restore pCh and pBegin temp = *pCh; *pCh = *pBegin; *pBegin = temp; &#125; &#125;&#125; 字符串的组合题目：输入一个字符串，输出该字符串中字符的所有组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。假设我们想在长度为n的字符串中求m个字符的组合。我们先从头扫描字符串的第一个字符。针对第一个字符，我们有两种选择：一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；而是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。这两种选择都很容易用递归实现。 下面是这种思路的参考代码：123456789101112131415161718192021222324252627282930313233void Combination(char* string)&#123; if(string == NULL) return; int length = strlen(string); vector&lt;char&gt; result; for(int i = 1; i &lt;= length; ++ i) &#123; Combination(string, i, result); &#125;&#125;void Combination(char* string, int number, vector&lt;char&gt;&amp; result)&#123; if(number == 0) &#123; vector&lt;char&gt;::iterator iter = result.begin(); for(; iter &lt; result.end(); ++ iter) printf("%c", *iter); printf("\n"); return; &#125; if(*string == '\0') return; result.push_back(*string); Combination(string + 1, number - 1, result); result.pop_back(); Combination(string + 1, number, result);&#125; 由于组合可以是1个字符的组合，2个字符的字符……一直到n个字符的组合，因此在函数void Combination(char* string)，我们需要一个for循环。另外，我们一个vector来存放选择放进组合里的字符。 memcpy默认实现12345678910111213141516void *memcpy1(void *desc, const void *src, size_t size)&#123; if((desc == NULL) &amp;&amp; (src == NULL)) &#123; return NULL; &#125; unsigned char *desc1 = (unsigned char*)desc; unsigned char *src1 = (unsigned char*)src; while(size-- &gt;0) &#123; *desc1 = *src1; desc1++; src1++; &#125; return desc;&#125; memcpy升级版本-处理重叠标准memcpy()的解释：12void *memcpy(void *dst, const void *src, size_t n);//If copying takes place between objects that overlap, the behavior is undefined. 注意下面的注释，对于地址重叠的情况，该函数的行为是未定义的。 另外，标准库也提供了地址重叠时的内存拷贝函数：memmove()，那么为什么还要考虑重写memcpy()函数呢? 因为memmove()函数的实现效率问题，该函数把源字符串拷贝到临时buf里，然后再从临时buf里写到目的地址，增加了一次不必要的开销。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void *Memcpy(void *dst, const void *src, size_t size);int main(int argc, char *argv[])&#123; char buf[100] = "abcdefghijk"; //memcpy(buf+2, buf, 5); Memcpy(buf+2, buf, 5); printf("%s\n", buf+2);&#125;void *Memcpy(void *dst, const void *src, size_t size)&#123; char *psrc; char *pdst; if(NULL == dst || NULL == src) &#123; return NULL; &#125; if((src &lt; dst) &amp;&amp; (char *)src + size &gt; (char *)dst) // 自后向前拷贝 &#123; psrc = (char *)src + size - 1; pdst = (char *)dst + size - 1; while(size--) &#123; *pdst-- = *psrc--; &#125; &#125; else &#123; psrc = (char *)src; pdst = (char *)dst; while(size--) &#123; *pdst++ = *psrc++; &#125; &#125; return dst;&#125; 使用Memcpy()的结果:1abcdehijk 使用memcpy()的结果:1abadehijk]]></content>
      <categories>
        <category>arithmetic</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-树]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-arithmetic-tree%2F</url>
    <content type="text"><![CDATA[判断平衡二叉树题目：输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 在遍历树的每个结点的时候，调用函数TreeDepth得到它的左右子树的深度。如果每个结点的左右子树的深度相差都不超过1，按照定义它就是一棵平衡的二叉树。这种思路对应的代码如下：12345678910111213bool IsBalanced(BinaryTreeNode* pRoot)&#123; if(pRoot == NULL) return true; int left = TreeDepth(pRoot-&gt;m_pLeft); int right = TreeDepth(pRoot-&gt;m_pRight); int diff = left - right; if(diff &gt; 1 || diff &lt; -1) return false; return IsBalanced(pRoot-&gt;m_pLeft) &amp;&amp; IsBalanced(pRoot-&gt;m_pRight);&#125; 上面的代码固然简洁，但我们也要注意到由于一个节点会被重复遍历多次，这种思路的时间效率不高。例如在函数IsBalance中输入上图中的二叉树，首先判断根结点（值为1的结点）的左右子树是不是平衡结点。此时我们将往函数TreeDepth输入左子树根结点（值为2的结点），需要遍历结点4、5、7。接下来判断以值为2的结点为根结点的子树是不是平衡树的时候，仍然会遍历结点4、5、7。毫无疑问，重复遍历同一个结点会影响性能。接下来我们寻找不需要重复遍历的算法。如果我们用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个结点之前我们已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的深度（某一结点的深度等于它到叶节点的路径的长度），我们就可以一边遍历一边判断每个结点是不是平衡的。下面是这种思路的参考代码： 12345678910111213141516171819202122bool IsBalanced(BinaryTreeNode* pRoot, int* pDepth)&#123; if(pRoot == NULL) &#123; *pDepth = 0; return true; &#125; int left, right; if(IsBalanced(pRoot-&gt;m_pLeft, &amp;left) &amp;&amp; IsBalanced(pRoot-&gt;m_pRight, &amp;right)) &#123; int diff = left - right; if(diff &lt;= 1 &amp;&amp; diff &gt;= -1) &#123; *pDepth = 1 + (left &gt; right ? left : right); return true; &#125; &#125; return false;&#125; 我们只需要给上面的函数传入二叉树的根结点以及一个表示结点深度的整形变量就可以了：12345bool IsBalanced(BinaryTreeNode* pRoot)&#123; int depth = 0; return IsBalanced(pRoot, &amp;depth);&#125; 在上面的代码中，我们用后序遍历的方式遍历整棵二叉树。在遍历某结点的左右子结点之后，我们可以根据它的左右子结点的深度判断它是不是平衡的，并得到当前结点的深度。当最后遍历到树的根结点的时候，也就判断了整棵二叉树是不是平衡二叉树了。 从上到下遍历二元树输入一颗二元树，从上往下按层打印树的每个结点，同一层中按照从左往右的顺序打印12345678910111213141516171819202122232425262728293031323334 8 / \ 6 10 / \ / \5 7 9 11输出 8 6 10 5 7 9 11。void PrintFromTopToBottom(BTreeNode *pTreeRoot)&#123; if(!pTreeRoot) return; // get a empty queue deque&lt;BTreeNode *&gt; dequeTreeNode; // insert the root at the tail of queue dequeTreeNode.push_back(pTreeRoot); while(dequeTreeNode.size()) &#123; // get a node from the head of queue BTreeNode *pNode = dequeTreeNode.front(); dequeTreeNode.pop_front(); // print the node cout &lt;&lt; pNode-&gt;m_nValue &lt;&lt; ' '; // print its left child sub-tree if it has if(pNode-&gt;m_pLeft) dequeTreeNode.push_back(pNode-&gt;m_pLeft); // print its right child sub-tree if it has if(pNode-&gt;m_pRight) dequeTreeNode.push_back(pNode-&gt;m_pRight); &#125;&#125; 二叉树后序遍历题目：输入一个整数数组，判断该数组是不是某二元查找树的后序遍历的结果。如果是返回true，否则返回false。例如输入5、7、6、9、11、10、8，由于这一整数序列是如下树的后序遍历结果：因此返回true。如果输入7、4、6、5，没有哪棵树的后序遍历的结果是这个序列，因此返回false。12345678910111213141516171819202122232425262728293031323334353637 8 / \ 6 10 / \ / \ 5 7 9 11bool verifySquenceOfBST(int squence[], int length)&#123; if(squence == NULL || length &lt;= 0) return false; // root of a BST is at the end of post order traversal squence int root = squence[length - 1]; // the nodes in left sub-tree are less than the root int i = 0; for(; i &lt; length - 1; ++ i) &#123; if(squence[i] &gt; root) break; &#125; // the nodes in the right sub-tree are greater than the root int j = i; for(; j &lt; length - 1; ++ j) &#123; if(squence[j] &lt; root) return false; &#125; // verify whether the left sub-tree is a BST bool left = true; if(i &gt; 0) left = verifySquenceOfBST(squence, i); // verify whether the right sub-tree is a BST bool right = true; if(i &lt; length - 1) right = verifySquenceOfBST(squence + i, length - i - 1); return (left &amp;&amp; right);&#125; 二元查找树的深度题目：输入一棵二元树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 123456789101112int TreeDepth(SBinaryTreeNode *pTreeNode)&#123; // the depth of a empty tree is 0 if(!pTreeNode) return 0; // the depth of left sub-tree int nLeft = TreeDepth(pTreeNode-&gt;m_pLeft); // the depth of right sub-tree int nRight = TreeDepth(pTreeNode-&gt;m_pRight); // depth is the binary tree return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1);&#125; 二元查找树的镜像123456789101112131415void MirrorRecursively(BSTreeNode *pNode)&#123; if(!pNode) return; // swap the right and left child sub-tree BSTreeNode *pTemp = pNode-&gt;m_pLeft; pNode-&gt;m_pLeft = pNode-&gt;m_pRight; pNode-&gt;m_pRight = pTemp; // mirror left child sub-tree if not null if(pNode-&gt;m_pLeft) MirrorRecursively(pNode-&gt;m_pLeft); // mirror right child sub-tree if not null if(pNode-&gt;m_pRight) MirrorRecursively(pNode-&gt;m_pRight);&#125; 最大/小堆100w个数中找出最大/i小的的100个数]]></content>
      <categories>
        <category>arithmetic</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-链表]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-arithmetic-linklist%2F</url>
    <content type="text"><![CDATA[从尾到头输出链表题目：输入一个链表的头结点，从尾到头反过来输出每个结点的值。从头到尾遍历链表，每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始输出结点的值，此时输出的结点的顺序已经反转过来了。该方法需要维护一个额外的栈，实现起来比较麻烦。既然想到了栈来实现这个函数，而递归本质上就是一个栈结构。于是很自然的又想到了用递归来实现。要实现反过来输出链表，我们每访问到一个结点的时候，先递归输出它后面的结点，再输出该结点自身，这样链表的输出结果就反过来了。12345678910111213void PrintListReversely(ListNode* pListHead)&#123; if(pListHead != NULL) &#123; // Print the next node first if (pListHead-&gt;m_pNext != NULL) &#123; PrintListReversely(pListHead-&gt;m_pNext); &#125; // Print this node printf("%d", pListHead-&gt;m_nKey); &#125;&#125; 寻找链表的第n个节点单链表差集已知集合A和B的元素分别用不含头结点的单链表存储，函数difference()用于求解集合A与B的差集，并将结果保存在集合A的单链表中。例如，若集合A={5,10,20,15,25,30}，集合B={5,15,35,25}，完成计算后A={10,20,30}。链表结点的结构类型定义如下：1234567891011121314151617181920212223242526272829303132struct node&#123; int elem; node* next;&#125;;void difference(node** LA , node* LB)&#123; node *pa , *pb , *pre , *q; pre = NULL; pa = *LA; //1 while(pa) &#123; pb = LB; while( pb &amp;&amp; ( pa-&gt;elem != pb-&gt;elem ) ) //2 pb = pb-&gt;next; if( pb ) //3 &#123; if( !pre ) *LA = pa-&gt;next ; //4 else pre = pa-&gt;next; //5 q = pa; pa = pa-&gt;next; free(q); &#125; else &#123; pre = pa; //6 pa = pa-&gt;next; &#125; &#125;&#125;]]></content>
      <categories>
        <category>arithmetic</category>
      </categories>
      <tags>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-排序]]></title>
    <url>%2F2016%2F12%2F23%2F2016-12-23-arithmetic-sort%2F</url>
    <content type="text"><![CDATA[视觉直观感受 7 种常用的排序算法 头文件如下:123456#define OK 0#define ERROR -1#define TRUE 1#define FALSE 0#define NULL (void*)0typedef int Status; 交换两个变量的值12345678910111213141516171819202122232425262728void Swap(int&amp; a, int&amp; b)&#123; #if 0 a = a + b - (b = a); #endif #if 0 b = a + (a = b) * 0; #endif #if 0 a = a + b; b = a - b; a = a - b; #endif #if 0 a = a * b; b = a / b; a = a / b; #endif #if 1 a = a ^ b; b = a ^ b; a = a ^ b; #endif&#125; 插入排序123456789101112131415161718192021222324252627282930313233/*性能: 1）稳定 2）空间代价：O(1) 3）时间代价：步骤: 1、从第一个元素开始，该元素可以认为已经被排序 2、取出下一个元素，在已经排序的元素序列中从后向前扫描 3、如果该元素（已排序）大于新元素，将该元素移到下一位置 4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 5、将新元素插入到该位置后 6、重复步骤2~5*/Status InsertSort(int array[], int len)&#123; if (NULL == array) &#123; return ERROR; &#125; register int i, j, temp; for (i = 1; i &lt; len; i++) &#123; temp = array[i]; j = i-1; //key1. before the current location while ((j &gt;= 0) &amp;&amp; (array[j] &gt; temp)) &#123; array[j+1] = array[j]; j--; &#125; array[j+1] = temp; //key2. pay attention to 'j+1' &#125; return OK;&#125; 二分插入排序12345678910111213141516171819202122232425262728293031323334353637383940/*性能: 1）稳定 2）空间代价：O(1) 2）时间间代价：步骤: 1、从第一个元素开始，该元素可以认为已经被排序 2、取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置 3、将新元素插入到该位置后 4、重复上述两步*/Status BinInsertSort(int array[], int len)&#123; if (NULL == array) &#123; return ERROR; &#125; register int i, j, temp, left, right, mid; for (i = 1; i &lt; len; i++) &#123; temp = array[i]; left = 0; right = i-1; while (left &lt;= right) &#123; mid = (left + right)/2; if (array[mid] &gt; temp) right = mid-1; else left = mid+1; &#125;//key. 此时left肯定就是待插入的位置坐标 for (j = i-1; j &gt; left; j--) &#123; array[j+1] = array[j]; &#125; array[left] = temp; &#125; return OK;&#125; 希尔排序1234567891011121314151617181920212223242526272829303132333435363738/*性能: 1） 2）空间代价： 2）时间间代价：步骤: 1、先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。 2、所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。 3、取第二个增量d2&lt;d1重复上述的分组和排序， 4、直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。*/Status ShellSort1(int array[], int len)&#123; register int i, j, k, gap, temp; for (gap = len/2; gap &gt; 0; gap /= 2) //步长 &#123; for (i = 0; i &lt; gap; i++) //直接插入排序 - 执行 gap 趟 &#123; for (j = i + gap; j &lt; len; j += gap) &#123; if (array[j] &lt; array[j - gap]) &#123; temp = array[j]; k = j - gap; while (k &gt; 0 &amp;&amp; array[k] &gt; temp) &#123; array[k + gap] = array[k]; k -= gap; &#125; array[k + gap] = temp; &#125; &#125; &#125; &#125; return OK;&#125; 选择排序12345678910111213141516171819202122232425262728293031323334/*性能: 1）稳定 2）空间代价：O(1) 2）时间间代价：步骤: 1、初始状态：无序区为R[1..n]，有序区为空。 2、第i趟排序(i=1,2,3...n-1) 第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。 该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换， 使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 3、前n-1趟结束，数组有序化了*/Status SelectSort(int array[], int len)&#123; if (NULL == array) &#123; return ERROR; &#125; register int i, j, min; for (i = 0; i &lt; len - 1; i++) &#123; min = i; for (j = i+1; j &lt; len; j++) &#123; if (array[min] &gt; array[j]) &#123; min = j; &#125; &#125; Swap(array[i], array[min]); &#125; return OK;&#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*性能: 1） 2）空间代价： 2）时间间代价：步骤: 一般都用数组来表示堆，i结点的父结点下标为(i-1)/2，左右子结点的下标分别为 2*i + 1和 2*i + 2 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。 堆即是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。1. 什么是堆? 我们这里提到的堆一般都指的是二叉堆，它满足二个特性： 1&gt;父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值 2&gt;每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）2、什么是堆调整(Heap Adjust)？ 这是为了保持堆的特性而做的一个操作。对某一个节点为根的子树做堆调整，其实就是将该根节点进行“下沉”操作 (具体是通过和子节点交换完成的)，一直下沉到合适的位置，使得刚才的子树满足堆的性质。 例如对最大堆的堆调整我们会这么做： 1、在对应的数组元素A[i], 左孩子A[LEFT(i)], 和右孩子A[RIGHT(i)]中找到最大的那一个，将其下标存储在largest中。 2、如果A[i]已经就是最大的元素，则程序直接结束。 3、否则，i的某个子结点为最大的元素，将A[largest]与A[i]交换。 4、再从交换的子节点开始，重复1,2,3步，直至叶子节点，算完成一次堆调整。 这里需要提一下的是，一般做一次堆调整的时间复杂度为log(n)。3、如何建堆? 建堆是一个通过不断的堆调整，使得整个二叉树中的数满足堆性质的操作。 在数组中的话，我们一般从下标为n/2的数开始做堆调整，一直到下标为0的数 (因为下标大于n/2的数都是叶子节点，其子树已经满足堆的性质了)4、如何进行堆排序 ? 堆排序是在上述3中对数组建堆的操作之后完成的。 数组储存成堆的形式之后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。 第二次将A[0]与A[n-2]交换，再对A[0…n-3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。 由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了 */#include&lt;math.h&gt;int parent(int i)&#123; return (int)floor((i - 1) / 2);&#125;int left(int i)&#123; return (2 * i + 1)&#125;int right(int i)&#123; return (2 * i + 2)&#125;void HeapAdjust(int array[], int i, int heap_size)&#123;&#125; 冒泡排序12345678910111213141516171819202122232425262728293031/*性能: 1）稳定 2）空间代价： 2）时间间代价：步骤: 1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 3、针对所有的元素重复以上的步骤，除了最后一个。 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。*/Status BubbleSort(int array[], int len)&#123; if (NULL == array) &#123; return ERROR; &#125; register int i, j; for (i = len; i &gt; 0; i--) &#123; for (j = 0; j &lt; i-1; j++) &#123; if (array[j] &gt; array[j+1]) //key 最大的数据沉底 &#123; Swap(array[j], array[j+1]); &#125; &#125; &#125; return OK;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041/*性能: 1）稳定 2）空间代价： 2）时间间代价：步骤: 1、从数列中挑出一个元素，称为 "基准"（pivot）， 2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。*/int Partition(int* data, int low, int high)&#123; int pivotkey = low; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; data[high] &gt; data[pivotkey]) &#123; high--; &#125; Swap(data[low], data[high]); while (low &lt; high &amp;&amp; data[low] &lt; data[pivotkey]) &#123; low++; &#125; Swap(data[low], data[high]); &#125; return low;&#125;Status QuickSort(int array[], int low, int high)&#123; int pivot; if (low &lt; high) &#123; pivot = Partition(array, low, high); QuickSort(array, low, pivot-1); QuickSort(array, pivot+1, high); &#125; return OK;&#125; 归并排序类]]></content>
      <categories>
        <category>arithmetic</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sport 运动主体架构]]></title>
    <url>%2F2016%2F12%2F22%2F2016-12-22-sport-architecture%2F</url>
    <content type="text"><![CDATA[本文主要介绍运动App的四方通讯架构 主体交互图如下： 手机运动PhoeSport 数据展示区 - 手机端 - 运动数据轨迹，记录，成就表展示 手机通讯端PhoneProxy 手表通讯代理，与手表蓝牙通讯，与PhoeSport之间aidl 接受消息类型12CMD_WATCH_SET_RUNNINT_DATA //Wear主动向Phone发送运动数据CMD_WATCH_ACTIVE_GET_RUNNING_RECORD //Wear端主动向Phone端请求Record 手表通讯端WearProxy 手机通讯代理，与手机蓝牙通讯，与WearSport之间aidl 接受消息类型1234567CMD_WATCH_SEND_RUNNINT_DATA_SUCCESS //运动数据发送Phone端成功的回复CMD_WATCH_SEND_RUNNINT_DATA_FAIL //运动数据发送Phone端失败的回复CMD_SEND_HEARTRATE_TRAIN_DATA_SUSCESS //心率数据发送Phone端成功的回复CMD_SEND_HEARTRATE_TRAIN_DATA_FAIL //心率数据发送Phone端失败的回复CMD_PHONE_GET_RUNNING_DATA //Phone端主动请求数据CMD_PHONE_SEND_RUNNING_RECORD //Phone端主动发送RecordCMD_PHONE_SEND_RUNNING_SETTING //Phone端主动发送设置 手表运动WearSport 数据采集 - 手表端 - 运动数据采集，心率数据采集]]></content>
      <categories>
        <category>works</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 命令速查]]></title>
    <url>%2F2016%2F12%2F18%2F2016-12-18-git-study%2F</url>
    <content type="text"><![CDATA[Git常用命令速查表 配置用户名邮箱12git config --global user.name "jingtalk"git config --global user.email "jinghuang1130@yahoo.com" 配置別名123456git config --global alias.ci commitgit config --global alias.check checkoutgit config --global alias.st statusgit config --global alias.br branchgit config --global alias.last "log -3 HEAD" #显示最新提交的3个日志git config --global alias.di diff 删除本地分支12git branch -d devgit branch -D dev #强制删除 删除远程分支1git branch -r -d origin/dev 上面只是删除本地对应远程分支的track, 正确做法1git push origin :dev 冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支 重命名本地分支12git branch -m dev newdevgit branch -m | -M oldbranch newbranch #重命名分支，如果newbranch名字分支已经存在，则需要使用-M强制重命名，否则，使用-m进行重命名 git重命名远程分支=先删除远程分支，然后重命名本地分支，再推送 新建分支本地新创建了一个local_br 需要推送到远程的 remote_br分支上 (冒号前后不要加空格)1git push origin local_br:remote_br cherry-pick在常规开发过程中，经常会遇到这样的问题，dev作为新功能提交分支，每天都有提交代码；而master作为稳定版本分支，可能一个月才提交一次，这样就会遇到dev的很多功能性代码部分合入master的需求，此时为使用cherry-pick的绝佳时机, commit_id为dev分支上提交的commit id123git checkout mastergit cherry-pick &lt;commit_id&gt; #此步可能会生冲突，但修改冲突的代价远小于代码比对合入git push origin master 查看代码库地址1git remote -v 新建仓库如果想保留仓库原有的文件夹名字1git clone https://github.com/JingTalk/jingtalk.github.io.git 如果想起一个新的名字12345mkdir jingtalkblogcd jingtalkbloggit initgit remote add origin https://github.com/JingTalk/jingtalk.github.io.gitgit pull origin master 添加远程库如果现在已经本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步；首先先在git上建立一个空的仓库jingtalk；然后可以将本地的仓库与jingtalk关联；12git remote add origin https://github.com/JingTalk/jingtalk.github.io.gitgit push -u origin master 第一次推送master分支时，使用-u参数，Git把本地的master分支推送的远程新的master分支，同时把本地的master分支和远程的master分支关联起来，以后只需要下面命令来推送最新修改1git push origin master commit撤销1234git reset --hard &lt;commit_id&gt; #彻底回退到某个版本，本地的源码也会变为上一个版本的内容，代码已删除git reset --hard HEAD^git reset --soft&lt;commit_id&gt; #回退到某个版本，只回退了commit的信息，代码没有删除git reset --soft HEAD^ 在Git中，用HEAD表示当前版本, 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100123git reset --hard HEADgit reset --hard HEAD^git reset --hard HEAD^^ 线上版本回退如果你的错误提交已经推送到自己的远程分支了，那么就需要回滚远程分支了。首先要回退本地分支：12git refloggit reset --hard commit_id 紧接着强制推送到远程分支：123git push -f// 上面如果执行报错，可以使用下面这种git push origin master -f 注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支 git reflog可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录12345678910F:\git_TOS\wear\twssports (goer_master_GA)λ git reflogbbb7bc3 HEAD@&#123;0&#125;: cherry-pick: 中英文修改58e8584 HEAD@&#123;1&#125;: reset: moving to 58e8584f6f39c84301c9399d3ffe2dfb8fd432310492752 HEAD@&#123;2&#125;: checkout: moving from dev to goer_master_GA27d8437 HEAD@&#123;3&#125;: checkout: moving from master to dev27d8437 HEAD@&#123;4&#125;: reset: moving to 27d843767ce98fb78faf7a03bfd8509faaa6b519f4767fd HEAD@&#123;5&#125;: checkout: moving from dev to master27d8437 HEAD@&#123;6&#125;: commit: 静置导致的关闭运动Toast添加运动状态判断d402152 HEAD@&#123;7&#125;: checkout: moving from goer_master_GA to dev 暂存修改12345git stashgit stash listgit stash applygit stash dropgit stash clear 查看提交记录12git loggit log &lt;file&gt; 删除git远程库中的文件1234git rm --cached -r gradle.properties#delete gradle.properties in .gitignoregit add .gitignoregit push origin master .gitignore规则123456# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：123git rm -r --cached .git add .git commit -m 'update .gitignore' SSH权限通过命令生成两个文件 id_rsa 和 id_rsa.pub ，而 id_rsa 是密钥，id_rsa.pub 就是公钥，将后者添加到github、coding.net相应的设置中即可通过ssh方式拉取代码（不用再输入用户名和密码）1ssh-keygen -t rsa -C jinghuang1130@yahoo.com Mac系统下的.ssh文件位于/Users/用户名/.ssh下面 Error问题refusinggit push origin master的时候，有时会报下面的错误12fatal: refusing to merge unrelated historiesError redoing merge 1234deadbeef1234deadbeef 使用 --allow-unrelated-histories 处理，如下1git push origin master --allow-unrelated-histories]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法记录]]></title>
    <url>%2F2016%2F12%2F02%2F2016-12-04-markdown%2F</url>
    <content type="text"><![CDATA[Markdown简介 Markdown 简单的世界 标题说明一 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 一级标题二级标题三级标题四级标题五级标题六级标题####### 七级标题（最多支持六级标题） 标题说明二 一级标题二级标题 列表说明 无序列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 文本 文本 文本 有序列表如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 文本 文本 文本 引用说明 在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 注：&gt; 和文本之间要保留一个字符的空格。 嵌套引用如下： 一级引用 二级引用 链接说明 行内式在 Markdown 中，插入链接不需要其他按钮，你只需要使用 显示文本 这样的语法即可 简书 参考式(注意下面的空行)简书主页 简书设置页 图片说明 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 这样的语法即可 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！ 粗体 斜体 Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法 一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 代码引用 需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。 如果引用的语句为多行，可以将12345## 一行代码引用（也可以当标记使用）`Hello World`## 多行代码引用 void main(){printf(“Hello, Markdown.”);}``` 空格或TAB键实现通过在每行加上4个空格或者一个制表符（如同写代码一样） 四个空格 void main() { printf(&quot;Hello, Markdown.&quot;); } TAB键 public void test() { ... } 段落说明 段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 分割线 分割线的语法只需要另起一行，连续输入三个星号 * 或者 — 即可, 如下： * 反斜杠\相当于反转义作用。使符号成为普通符号 换行符一行结束时输入两个空格，如下：[上一行没有打空格] 这是第一行[上一行打了空格]这是第二行 高亮在相应的text前后添加两个=即可 ==DYX== 删除线DYX]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2015%2F11%2F21%2F2015-11-21-hello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy npm 代理12npm config set https-proxy http://dev-proxy.web.com:8080npm config set proxy http://dev-proxy.web.com:8080 npm 安装安装完node.js后，在本地安装hexo1npm install hexo-cli -g 然后下载hexoblog的源码，最后执行12hexo s // 本地发表hexo g -d // 发布到相应网站 More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>